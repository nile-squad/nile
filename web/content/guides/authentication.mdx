---
title: Authentication Guide
description: Learn how to secure your Nile services with authentication and authorization
---

**Version:** 1.1  
**Date:** January 16, 2025  
**Author:** Hussein Kizz

## Overview

Nile is secure by default. All actions require authentication unless explicitly marked as public. This guide shows you how to set up and use authentication in your Nile application with **configurable authentication methods**.

## Configurable Authentication

Nile now supports **developer-configurable authentication methods** through the `serverOptions.auth` configuration. You can explicitly specify where JWT tokens should be extracted from:

### Server Configuration

```typescript
import { createRESTRPC } from '@nile-squad/nile/rest-rpc';

const serverConfig = {
  serverName: 'my-api',
  baseUrl: '/api',
  apiVersion: 'v1',
  services: [/* your services */],
  
  // Configurable authentication
  auth: {
    method: 'payload',        // 'payload' | 'cookie' | 'header'
    secret: process.env.AUTH_SECRET,
    cookieName: 'auth_token', // Optional: custom cookie name
    headerName: 'authorization' // Optional: custom header name
  }
};
```

### Authentication Methods

#### Payload Method (Default)
Extract JWT tokens from the request payload body.

```typescript
// Server configuration
auth: {
  method: 'payload',
  secret: process.env.AUTH_SECRET
}

// Client usage
const response = await fetch('/api/services/customers', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({
    action: 'create',
    payload: { name: 'John Doe' },
    auth: { token: 'your-jwt-token' }  // Token in payload
  })
});
```

#### Cookie Method (HttpOnly)
Extract JWT tokens from HTTP-only cookies for enhanced security.

```typescript
// Server configuration
auth: {
  method: 'cookie',
  secret: process.env.AUTH_SECRET,
  cookieName: 'auth_token'  // Optional: defaults to 'auth_token'
}

// Client usage (cookie set by server)
const response = await fetch('/api/services/customers', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  credentials: 'include',  // Include cookies
  body: JSON.stringify({
    action: 'create',
    payload: { name: 'John Doe' }
    // No auth object needed - token comes from cookie
  })
});
```

#### Header Method (Bearer Token)
Extract JWT tokens from Authorization headers.

```typescript
// Server configuration
auth: {
  method: 'header',
  secret: process.env.AUTH_SECRET,
  headerName: 'authorization'  // Optional: defaults to 'authorization'
}

// Client usage
const response = await fetch('/api/services/customers', {
  method: 'POST',
  headers: { 
    'Content-Type': 'application/json',
    'Authorization': 'Bearer your-jwt-token'  // Token in header
  },
  body: JSON.stringify({
    action: 'create',
    payload: { name: 'John Doe' }
  })
});
```

## Authentication Modes

Nile supports three authentication modes:

### User Authentication

Standard user authentication for client applications.

**Use when:**

- Building web or mobile applications
- Users need to authenticate
- Each user has their own data and permissions

**Setup:**

```typescript
// Configure JWT authentication
const serverConfig = {
  auth: {
    method: 'header',  // or 'payload' or 'cookie'
    secret: process.env.AUTH_SECRET,
    headerName: 'authorization'  // Optional: defaults to 'authorization'
  },
  // ... other config
};
```

**Client usage (Header method):**

```bash
curl -X POST http://localhost:3000/services/accounts \
  -H "Authorization: Bearer <jwt-token>" \
  -H "Content-Type: application/json" \
  -d '{
    "action": "create",
    "payload": { "name": "John", "email": "john@example.com" }
  }'
```

**Client usage (Payload method):**

```bash
curl -X POST http://localhost:3000/services/accounts \
  -H "Content-Type: application/json" \
  -d '{
    "action": "create",
    "payload": { "name": "John", "email": "john@example.com" },
    "auth": { "token": "<jwt-token>" }
  }'
```

### Session Authentication

Browser-based session authentication using cookies.

**Use when:**

- Building traditional web applications
- Need CSRF protection
- Want automatic session management
- Enhanced security with HttpOnly cookies

**Setup:**

```typescript
// Better Auth integration example
import { betterAuth } from 'better-auth';

const auth = betterAuth({
  database: db,
  emailAndPassword: {
    enabled: true,
  },
});

// Nile configuration for cookie-based authentication
const serverConfig = {
  auth: {
    method: 'cookie',
    secret: process.env.AUTH_SECRET,
    cookieName: 'better-auth.session_token'  // Match Better Auth cookie name
  },
  // ... other config
};
```

**Client usage:**

```bash
curl -X POST http://localhost:3000/services/accounts \
  -H "Cookie: better-auth.session_token=<session>" \
  -H "Content-Type: application/json" \
  -d '{
    "action": "create",
    "payload": { "name": "John", "email": "john@example.com" }
  }'
```

### Agent Authentication

Internal authentication for AI agents and automated systems.

**Use when:**

- Building AI agents
- Internal automation
- Service-to-service communication

**Setup:**

```typescript
import { createRPC } from '@nile-squad/nile/rest-rpc';

const rpc = createRPC({
  agentMode: true,
  organization_id: 'org-uuid',
  serverConfig
});

const result = await rpc.executeServiceAction('accounts', {
  action: 'create',
  payload: { name: 'John', email: 'john@example.com' }
});
```

## Making Actions Public

By default, all actions require authentication. Make actions public when needed:

### Single Public Action

```typescript
{
  name: 'getPublicProfile',
  description: 'Get public user profile',
  isProtected: false,  // Anyone can call this
  handler: async (data) => {
    // Your logic
  }
}
```

### Service-Level Public Actions

```typescript
{
  name: 'accounts',
  description: 'User account management',
  publicActions: ['register', 'getPublicProfile'],
  actions: [
    // All actions here except those in publicActions require auth
  ]
}
```

## Accessing User Context

Authenticated user information is available in the handler context:

```typescript
{
  name: 'updateProfile',
  isProtected: true,
  handler: async (data, context) => {
    const { user } = context;
    
    console.log('User ID:', user.id);
    console.log('User email:', user.email);
    console.log('User role:', user.role);
    console.log('Organization:', user.organizationId);
    
    // Update only the authenticated user's profile
    return updateUserProfile(user.id, data);
  }
}
```

**Context object includes:**

- `user.id` - User's unique identifier
- `user.email` - User's email address
- `user.role` - User's role (admin, user, etc.)
- `user.organizationId` - Organization context
- `user.metadata` - Additional user metadata

## Role-Based Access Control

Implement RBAC using the meta system and action hooks:

### Define Access Rules

```typescript
{
  name: 'users',
  tableName: 'users',
  idName: 'id',
  meta: {
    access: {
      create: ['owner', 'admin'],
      read: ['owner', 'admin', 'manager', 'member'],
      update: ['owner', 'admin', 'manager'],
      delete: ['owner', 'admin']
    }
  }
}
```

### Create Access Control Hook

```typescript
import { Ok, safeError } from '@nile-squad/nile';

export const accessControlHook = (context, action, payload) => {
  const { user } = context;
  
  // Skip for unauthenticated users
  if (!user) {
    return Ok(true);
  }
  
  const userRole = user.role || 'member';
  
  // Check access rules
  const accessMeta = action.meta?.access;
  if (!accessMeta) {
    return safeError('Access denied: No permissions defined', 'no-access-meta');
  }
  
  // For auto-generated actions
  let allowedRoles;
  if (action.type === 'auto') {
    allowedRoles = accessMeta[action.name];
  } else {
    allowedRoles = accessMeta;
  }
  
  if (!allowedRoles || !allowedRoles.includes(userRole)) {
    return safeError(`Access denied for role: ${userRole}`, 'access-denied');
  }
  
  return Ok(true);
};
```

### Register Global Hook

```typescript
const serverConfig = {
  onActionHandler: accessControlHook,
  // ... other config
};
```

## JWT Token Format

Nile expects JWT tokens with this structure:

```json
{
  "sub": "user-id",
  "email": "user@example.com",
  "role": "admin",
  "organizationId": "org-uuid",
  "exp": 1234567890
}
```

**Generate a token:**

```typescript
import jwt from 'jsonwebtoken';

const token = jwt.sign(
  {
    sub: user.id,
    email: user.email,
    role: user.role,
    organizationId: user.organizationId
  },
  process.env.AUTH_SECRET,
  { expiresIn: '7d' }
);
```

## Better Auth Integration

Nile works seamlessly with Better Auth:

### Setup Better Auth

```typescript
import { betterAuth } from 'better-auth';
import { drizzleAdapter } from 'better-auth/adapters/drizzle';

export const auth = betterAuth({
  database: drizzleAdapter(db, {
    provider: 'pg',
  }),
  emailAndPassword: {
    enabled: true,
  },
  session: {
    expiresIn: 60 * 60 * 24 * 7, // 7 days
  },
});
```

### Add Auth Endpoints

```typescript
import { auth } from './auth';

// Better Auth handles these routes automatically
app.on(['POST', 'GET'], '/api/auth/**', (c) => {
  return auth.handler(c.req.raw);
});
```

### Frontend Integration

```typescript
import { createAuthClient } from 'better-auth/react';

const authClient = createAuthClient({
  baseURL: 'http://localhost:3000',
});

// Sign in
await authClient.signIn.email({
  email: 'user@example.com',
  password: 'password',
});

// The session cookie is set automatically
// Now you can call protected Nile endpoints
const response = await fetch('/services/accounts', {
  method: 'POST',
  credentials: 'include', // Include cookies
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({
    action: 'create',
    payload: { name: 'John', email: 'john@example.com' }
  })
});
```

## Custom Configuration

You can customize cookie and header names for your specific needs:

```typescript
// Custom cookie name
auth: {
  method: 'cookie',
  secret: process.env.AUTH_SECRET,
  cookieName: 'custom_auth_token'  // Custom cookie name
}

// Custom header name
auth: {
  method: 'header',
  secret: process.env.AUTH_SECRET,
  headerName: 'x-custom-auth'  // Custom header name
}
```

## Custom Authentication

Implement custom authentication logic:

```typescript
import { verifyToken } from './custom-auth';

const serverConfig = {
  authSecret: process.env.AUTH_SECRET,
  customAuth: async (request) => {
    // Extract token from custom header
    const token = request.headers.get('X-Custom-Token');
    
    if (!token) {
      return null;
    }
    
    // Verify token with your logic
    const user = await verifyToken(token);
    
    return user ? {
      id: user.id,
      email: user.email,
      role: user.role,
      organizationId: user.organizationId
    } : null;
  },
  // ... other config
};
```

## Troubleshooting

### Authentication Required Error

**Issue:** Getting "Authentication required" for public endpoints

**Solution:** Mark actions as public:

```typescript
{
  name: 'publicAction',
  isProtected: false,
  handler: async (data) => { /* ... */ }
}
```

### Invalid Token Error

**Issue:** Token is rejected as invalid

**Solution:** Check:

- Token is properly signed with AUTH_SECRET
- Token hasn't expired
- Token has required claims (sub, email)
- Authorization header format is correct

### User Context Missing

**Issue:** `context.user` is undefined in protected action

**Solution:** Verify:

- Request includes authentication header
- Token is valid and not expired
- Auth middleware is configured properly

### CORS Issues

**Issue:** Authentication fails due to CORS errors

**Solution:** Configure CORS properly:

```typescript
const serverConfig = {
  allowedOrigins: ['http://localhost:3000'],
  // ... other config
};
```

## Security Best Practices

### Store Secrets Securely

```typescript
// Use environment variables
const serverConfig = {
  authSecret: process.env.AUTH_SECRET,
  // Never hardcode secrets
};
```

### Use HTTPS in Production

Always use HTTPS in production to protect authentication tokens in transit.

### Set Appropriate Token Expiry

```typescript
const token = jwt.sign(payload, secret, {
  expiresIn: '7d' // Not too long, not too short
});
```

### Validate Input

Always validate user input even for authenticated users:

```typescript
{
  name: 'updateProfile',
  isProtected: true,
  validation: {
    zodSchema: updateProfileSchema
  },
  handler: async (data, context) => {
    // Data is already validated
  }
}
```

### Implement Rate Limiting

Protect against brute force attacks:

```typescript
const serverConfig = {
  rateLimit: {
    windowMs: 15 * 60 * 1000, // 15 minutes
    max: 100 // limit each IP to 100 requests per windowMs
  },
  // ... other config
};
```

## Next Steps

- **[Action Hooks](/docs/guides/hooks)** - Implement custom authorization logic
- **[REST-RPC API](/docs/api-reference/rest-rpc)** - Learn about authentication headers
- **[Core Concepts](/docs/core-concepts)** - Understand protected vs public actions

**Author:** [Hussein Kizz](https://github.com/Hussseinkizz) at [Nile Squad Labz](https://github.com/nile-squad)

*This documentation reflects the current implementation and is subject to evolution. Contributions and feedback are welcome.*
